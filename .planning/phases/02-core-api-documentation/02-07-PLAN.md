---
phase: 02-core-api-documentation
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/polymarket/real-time/README.md
  - skills/polymarket/real-time/websocket-overview.md
  - skills/polymarket/real-time/market-channel.md
autonomous: true

must_haves:
  truths:
    - "Documentation explains WebSocket architecture and connection setup"
    - "Documentation covers market channel subscription patterns"
    - "Documentation explains orderbook and price update handling"
    - "Code examples demonstrate working WebSocket connections"
  artifacts:
    - path: "skills/polymarket/real-time/README.md"
      provides: "Index for real-time data skill"
      min_lines: 50
    - path: "skills/polymarket/real-time/websocket-overview.md"
      provides: "WebSocket architecture and setup"
      min_lines: 80
    - path: "skills/polymarket/real-time/market-channel.md"
      provides: "Market channel subscription and events"
      min_lines: 100
  key_links:
    - from: "skills/polymarket/real-time/README.md"
      to: "websocket-overview.md, market-channel.md"
      via: "documentation index links"
      pattern: "\\[.*\\]\\(\\./.*\\.md\\)"
---

<objective>
Document WebSocket fundamentals and market channel for real-time data streaming.

Purpose: Enable Claude to understand WebSocket architecture and implement market data streaming. Covers WS-01 (connection setup), WS-02 (price streams), WS-05 (orderbook).

Output: Three skill files in skills/polymarket/real-time/ covering WebSocket basics and market data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-api-documentation/02-RESEARCH.md

# Reference Phase 1 style
@skills/polymarket/auth/README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket overview documentation</name>
  <files>skills/polymarket/real-time/websocket-overview.md</files>
  <action>
Create comprehensive WebSocket overview documentation (WS-01) covering:

1. **WebSocket Architecture:**
   - Two main WebSocket endpoints
   - CLOB WebSocket: `wss://ws-subscriptions-clob.polymarket.com/ws/market`
   - User WebSocket: `wss://ws-subscriptions-clob.polymarket.com/ws/user`

2. **Channel Types:**
   | Channel | URL | Auth Required | Purpose |
   |---------|-----|---------------|---------|
   | Market | /ws/market | No | Orderbook, price updates |
   | User | /ws/user | Yes | Order fills, trade notifications |

3. **Connection Setup:**
   ```python
   import asyncio
   import websockets
   import json

   MARKET_WS = "wss://ws-subscriptions-clob.polymarket.com/ws/market"
   USER_WS = "wss://ws-subscriptions-clob.polymarket.com/ws/user"

   async def connect_market():
       """Basic market channel connection."""
       async with websockets.connect(MARKET_WS) as ws:
           # Subscribe to markets
           subscribe_msg = {
               "type": "market",
               "assets_ids": ["71321...", "72541..."]  # Token IDs
           }
           await ws.send(json.dumps(subscribe_msg))

           # Receive messages
           async for message in ws:
               data = json.loads(message)
               print(f"Received: {data}")
   ```

4. **Subscription Message Format:**
   ```python
   # Market channel subscription
   {
       "type": "market",
       "assets_ids": ["token_id_1", "token_id_2"]
   }

   # User channel subscription (authenticated)
   {
       "type": "user",
       "auth": {
           "apiKey": "...",
           "secret": "...",
           "passphrase": "..."
       },
       "markets": ["condition_id_1", "condition_id_2"]
   }
   ```

5. **Message Types Overview:**
   | Event Type | Channel | Description |
   |------------|---------|-------------|
   | book | Market | Full orderbook snapshot |
   | price_change | Market | Incremental price update |
   | tick_size_change | Market | Tick size changed |
   | last_trade_price | Market | Trade executed |
   | MATCHED | User | Order matched |
   | PLACEMENT | User | Order placed |
   | CANCELLATION | User | Order cancelled |

6. **When to Use WebSocket vs REST:**
   | Use Case | WebSocket | REST |
   |----------|-----------|------|
   | Live price display | Yes | No |
   | Order notifications | Yes | No |
   | Initial data fetch | No | Yes |
   | Historical queries | No | Yes |
   | High-frequency updates | Yes | No |

7. **Dependencies:**
   ```bash
   pip install websockets asyncio
   ```
  </action>
  <verify>File exists at skills/polymarket/real-time/websocket-overview.md with 80+ lines covering architecture, channels, connection setup, and message types</verify>
  <done>WebSocket overview documented with connection patterns and channel architecture</done>
</task>

<task type="auto">
  <name>Task 2: Create market channel documentation</name>
  <files>skills/polymarket/real-time/market-channel.md</files>
  <action>
Create comprehensive market channel documentation (WS-02, WS-05) covering:

1. **Market Channel Connection:**
   ```python
   import asyncio
   import websockets
   import json

   MARKET_WS = "wss://ws-subscriptions-clob.polymarket.com/ws/market"

   async def subscribe_to_market(token_ids: list, callback):
       """Subscribe to market channel for orderbook updates."""
       async with websockets.connect(MARKET_WS) as ws:
           # Subscribe
           await ws.send(json.dumps({
               "type": "market",
               "assets_ids": token_ids
           }))

           async for message in ws:
               data = json.loads(message)
               await callback(data)
   ```

2. **Orderbook Snapshot (WS-05):**
   ```python
   # "book" event - Full orderbook snapshot
   {
       "event_type": "book",
       "asset_id": "71321...",
       "market": "0x...",
       "bids": [
           {"price": "0.45", "size": "1000.0"},
           {"price": "0.44", "size": "500.0"}
       ],
       "asks": [
           {"price": "0.46", "size": "800.0"},
           {"price": "0.47", "size": "600.0"}
       ],
       "timestamp": 1705320000
   }
   ```

3. **Price Change Events (WS-02):**
   ```python
   # "price_change" event - Incremental update
   {
       "event_type": "price_change",
       "asset_id": "71321...",
       "market": "0x...",
       "price": "0.46",
       "side": "ask",  # or "bid"
       "size": "0.0",  # Size 0 means level removed
       "timestamp": 1705320001
   }
   ```

4. **Trade Price Event:**
   ```python
   # "last_trade_price" event - Trade executed
   {
       "event_type": "last_trade_price",
       "asset_id": "71321...",
       "market": "0x...",
       "price": "0.455",
       "size": "50.0",
       "side": "buy",
       "timestamp": 1705320002
   }
   ```

5. **Tick Size Change Event:**
   ```python
   # "tick_size_change" event - Dynamic tick size update
   {
       "event_type": "tick_size_change",
       "asset_id": "71321...",
       "market": "0x...",
       "old_tick_size": "0.01",
       "new_tick_size": "0.001",
       "timestamp": 1705320003
   }
   ```
   Note: Tick sizes change when price > 0.96 or < 0.04

6. **Maintaining Local Orderbook:**
   ```python
   class OrderbookManager:
       def __init__(self):
           self.books = {}  # asset_id -> {"bids": {}, "asks": {}}

       async def handle_message(self, data):
           event_type = data.get("event_type")
           asset_id = data.get("asset_id")

           if event_type == "book":
               # Full snapshot - replace entire book
               self.books[asset_id] = {
                   "bids": {b["price"]: b["size"] for b in data["bids"]},
                   "asks": {a["price"]: a["size"] for a in data["asks"]}
               }

           elif event_type == "price_change":
               # Incremental update
               side = "bids" if data["side"] == "bid" else "asks"
               price = data["price"]
               size = data["size"]

               if float(size) == 0:
                   # Remove level
                   self.books[asset_id][side].pop(price, None)
               else:
                   # Update level
                   self.books[asset_id][side][price] = size

       def get_best_bid(self, asset_id):
           bids = self.books.get(asset_id, {}).get("bids", {})
           if bids:
               return max(bids.keys(), key=float)
           return None

       def get_best_ask(self, asset_id):
           asks = self.books.get(asset_id, {}).get("asks", {})
           if asks:
               return min(asks.keys(), key=float)
           return None
   ```

7. **Multiple Market Subscription:**
   ```python
   async def subscribe_multiple_markets(token_ids: list):
       """Subscribe to multiple markets in one connection."""
       async with websockets.connect(MARKET_WS) as ws:
           await ws.send(json.dumps({
               "type": "market",
               "assets_ids": token_ids  # Up to reasonable limit
           }))

           async for message in ws:
               data = json.loads(message)
               asset_id = data.get("asset_id")
               # Route to appropriate handler
               print(f"[{asset_id}] {data.get('event_type')}")
   ```

8. **Practical Price Streaming:**
   ```python
   async def stream_prices(token_id: str, duration_seconds: int = 60):
       """Stream price updates for a specified duration."""
       import time
       end_time = time.time() + duration_seconds

       async with websockets.connect(MARKET_WS) as ws:
           await ws.send(json.dumps({
               "type": "market",
               "assets_ids": [token_id]
           }))

           async for message in ws:
               if time.time() > end_time:
                   break

               data = json.loads(message)
               event_type = data.get("event_type")

               if event_type == "last_trade_price":
                   print(f"Trade: {data['price']} x {data['size']}")
               elif event_type == "price_change":
                   print(f"Book: {data['side']} {data['price']} = {data['size']}")
   ```
  </action>
  <verify>File exists at skills/polymarket/real-time/market-channel.md with 100+ lines, includes orderbook snapshot, price changes, and local orderbook management</verify>
  <done>Market channel documentation with orderbook streaming and price update handling</done>
</task>

<task type="auto">
  <name>Task 3: Create real-time README index</name>
  <files>skills/polymarket/real-time/README.md</files>
  <action>
Create README index for real-time skill following Phase 1 README style:

1. **Quick Start:**
   - Fastest path to streaming market data
   - Basic code snippet for price streaming
   - Link to detailed documentation

2. **Prerequisites:**
   - Python with websockets library
   - Token IDs from market discovery
   - API credentials for user channel only

3. **Documentation Index:**
   Table with columns: Document | Purpose | When to Read
   - websocket-overview.md - Architecture and setup - Understanding WebSocket system
   - market-channel.md - Orderbook and price streams - Market data streaming
   - (placeholder for user-channel.md - Plan 08)
   - (placeholder for connection-management.md - Plan 08)

4. **Channel Quick Reference:**
   | Need | Channel | Auth Required |
   |------|---------|---------------|
   | Price updates | Market | No |
   | Orderbook depth | Market | No |
   | Order notifications | User | Yes |
   | Trade confirmations | User | Yes |

5. **Common Issues:**
   - Data stops after ~20 minutes: Implement reconnection (see connection-management.md)
   - Missed messages: Use incremental updates, not just snapshots
   - Connection drops: Add heartbeat ping every 5 seconds

6. **Related Skills:**
   - Market Discovery (../market-discovery/) - Get token IDs to subscribe
   - Trading (../trading/) - Place orders tracked via user channel
   - Data Analytics (../data-analytics/) - Historical data (REST, not WebSocket)

Include "Last updated" footer with date and "Status: In Progress - Phase 2" note.
  </action>
  <verify>File exists at skills/polymarket/real-time/README.md with 50+ lines, has quick start, documentation index, and follows Phase 1 format</verify>
  <done>Real-time README provides navigation index and quick start for WebSocket streaming</done>
</task>

</tasks>

<verification>
All three files created in skills/polymarket/real-time/:
- README.md with skill index
- websocket-overview.md with architecture and setup
- market-channel.md with orderbook and price streaming

WS-01, WS-02, WS-05 requirements covered.
</verification>

<success_criteria>
1. skills/polymarket/real-time/ directory exists with 3 files
2. WebSocket architecture documented with both channels
3. Market channel subscription pattern documented
4. Orderbook snapshot and incremental updates documented
5. Price streaming with trade events documented
6. Local orderbook maintenance pattern included
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-api-documentation/02-07-SUMMARY.md`
</output>
