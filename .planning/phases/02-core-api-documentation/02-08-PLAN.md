---
phase: 02-core-api-documentation
plan: 08
type: execute
wave: 2
depends_on: ["02-07"]
files_modified:
  - skills/polymarket/real-time/user-channel.md
  - skills/polymarket/real-time/connection-management.md
autonomous: true

must_haves:
  truths:
    - "Documentation covers user-specific streams with authentication"
    - "Documentation explains order fills and trade notifications"
    - "Documentation covers connection lifecycle management"
    - "Documentation explains heartbeat and reconnection patterns"
  artifacts:
    - path: "skills/polymarket/real-time/user-channel.md"
      provides: "User channel with order and trade events"
      min_lines: 80
    - path: "skills/polymarket/real-time/connection-management.md"
      provides: "Heartbeat, timeout, and reconnection patterns"
      min_lines: 100
  key_links:
    - from: "skills/polymarket/real-time/user-channel.md"
      to: "skills/polymarket/auth/api-credentials.md"
      via: "authentication credentials"
      pattern: "apiKey|secret|passphrase"
    - from: "skills/polymarket/real-time/connection-management.md"
      to: "websocket-overview.md"
      via: "connection lifecycle"
      pattern: "websocket|connect"
---

<objective>
Complete WebSocket documentation with user channel and connection management patterns.

Purpose: Enable Claude to implement authenticated user streams and robust connection handling. Covers WS-03 (lifecycle), WS-04 (user streams).

Output: Two skill files completing the real-time skill folder.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-api-documentation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user channel documentation</name>
  <files>skills/polymarket/real-time/user-channel.md</files>
  <action>
Create comprehensive user channel documentation (WS-04) covering:

1. **User Channel Overview:**
   - Endpoint: `wss://ws-subscriptions-clob.polymarket.com/ws/user`
   - Requires API credentials (apiKey, secret, passphrase)
   - Provides order and trade notifications for authenticated user

2. **Authenticated Connection:**
   ```python
   import asyncio
   import websockets
   import json

   USER_WS = "wss://ws-subscriptions-clob.polymarket.com/ws/user"

   async def connect_user_channel(api_creds: dict, market_ids: list):
       """Connect to user channel for order notifications."""
       async with websockets.connect(USER_WS) as ws:
           # Authenticated subscription
           subscribe_msg = {
               "type": "user",
               "auth": {
                   "apiKey": api_creds["apiKey"],
                   "secret": api_creds["secret"],
                   "passphrase": api_creds["passphrase"]
               },
               "markets": market_ids  # List of condition IDs
           }
           await ws.send(json.dumps(subscribe_msg))

           async for message in ws:
               data = json.loads(message)
               await handle_user_event(data)
   ```

3. **Getting API Credentials:**
   ```python
   # From py-clob-client (see ../auth/api-credentials.md)
   creds = client.create_or_derive_api_creds()
   # creds = {"apiKey": "...", "secret": "...", "passphrase": "..."}
   ```

4. **Order Event Types:**
   ```python
   # PLACEMENT - Order placed on book
   {
       "type": "PLACEMENT",
       "order_id": "0x123...",
       "market": "0x...",
       "asset_id": "71321...",
       "side": "BUY",
       "price": "0.45",
       "size": "100.0",
       "timestamp": 1705320000
   }

   # MATCHED - Order (partially) filled
   {
       "type": "MATCHED",
       "order_id": "0x123...",
       "market": "0x...",
       "asset_id": "71321...",
       "side": "BUY",
       "price": "0.45",
       "size_matched": "50.0",    # Amount filled this match
       "remaining": "50.0",       # Remaining size
       "status": "MATCHED",       # or "FILLED" if complete
       "timestamp": 1705320001
   }

   # CANCELLATION - Order cancelled
   {
       "type": "CANCELLATION",
       "order_id": "0x123...",
       "market": "0x...",
       "reason": "USER_CANCELLED",  # or "EXPIRED", etc.
       "timestamp": 1705320002
   }
   ```

5. **Trade Notification Events:**
   ```python
   # Trade lifecycle states
   {
       "type": "TRADE",
       "status": "MINED",  # MATCHED -> MINED -> CONFIRMED
       "trade_id": "0x...",
       "order_id": "0x123...",
       "market": "0x...",
       "asset_id": "71321...",
       "side": "BUY",
       "price": "0.45",
       "size": "50.0",
       "fee": "0.0",
       "transaction_hash": "0x...",
       "timestamp": 1705320003
   }

   # Trade status progression:
   # MATCHED -> Trade matched with counterparty
   # MINED -> Transaction included in block
   # CONFIRMED -> Transaction confirmed
   # RETRYING -> Transaction failed, retrying
   # FAILED -> Trade failed (rare)
   ```

6. **Event Handler Pattern:**
   ```python
   async def handle_user_event(data):
       """Route user events to appropriate handlers."""
       event_type = data.get("type")

       if event_type == "PLACEMENT":
           print(f"Order placed: {data['order_id']}")
           print(f"  {data['side']} {data['size']} @ {data['price']}")

       elif event_type == "MATCHED":
           print(f"Order matched: {data['order_id']}")
           print(f"  Filled: {data['size_matched']}, Remaining: {data['remaining']}")
           if data.get("status") == "FILLED":
               print("  Order completely filled!")

       elif event_type == "CANCELLATION":
           print(f"Order cancelled: {data['order_id']}")
           print(f"  Reason: {data['reason']}")

       elif event_type == "TRADE":
           print(f"Trade {data['status']}: {data['trade_id']}")
           if data["status"] == "CONFIRMED":
               print(f"  TX: {data['transaction_hash']}")
   ```

7. **Subscribing to Multiple Markets:**
   ```python
   # Subscribe to specific markets only
   subscribe_msg = {
       "type": "user",
       "auth": {...},
       "markets": [
           "0xCondition1...",
           "0xCondition2...",
           "0xCondition3..."
       ]
   }

   # Or subscribe to all markets (omit markets field)
   subscribe_msg = {
       "type": "user",
       "auth": {...}
   }
   ```

8. **Complete User Stream Example:**
   ```python
   class UserStreamHandler:
       def __init__(self, api_creds: dict):
           self.creds = api_creds
           self.orders = {}  # Track order states
           self.running = False

       async def start(self, market_ids: list = None):
           self.running = True

           while self.running:
               try:
                   async with websockets.connect(USER_WS) as ws:
                       msg = {
                           "type": "user",
                           "auth": self.creds
                       }
                       if market_ids:
                           msg["markets"] = market_ids

                       await ws.send(json.dumps(msg))

                       async for message in ws:
                           data = json.loads(message)
                           await self.handle_event(data)

               except websockets.ConnectionClosed:
                   print("Connection closed, reconnecting...")
                   await asyncio.sleep(5)

       async def handle_event(self, data):
           order_id = data.get("order_id")
           if order_id:
               self.orders[order_id] = data
           # Process event...

       def stop(self):
           self.running = False
   ```
  </action>
  <verify>File exists at skills/polymarket/real-time/user-channel.md with 80+ lines, includes authenticated connection, order events, trade notifications, and event handling</verify>
  <done>User channel documentation with authenticated streams and order/trade event handling</done>
</task>

<task type="auto">
  <name>Task 2: Create connection management documentation</name>
  <files>skills/polymarket/real-time/connection-management.md</files>
  <action>
Create comprehensive connection management documentation (WS-03) covering:

1. **Known Connection Issues:**
   - Data stops flowing after ~20 minutes (connection appears open)
   - No explicit disconnect - need proactive detection
   - Subscription state lost on reconnection

2. **Heartbeat Pattern:**
   ```python
   import asyncio
   import websockets

   async def heartbeat(ws, interval: int = 5):
       """Send ping every N seconds to keep connection alive."""
       while True:
           await asyncio.sleep(interval)
           try:
               await ws.ping()
           except websockets.ConnectionClosed:
               break
   ```

3. **Data Timeout Detection:**
   ```python
   from datetime import datetime

   class ConnectionMonitor:
       def __init__(self, timeout_seconds: int = 300):  # 5 minutes
           self.last_data_time = datetime.now()
           self.timeout_seconds = timeout_seconds

       def on_data_received(self):
           """Call whenever data is received."""
           self.last_data_time = datetime.now()

       def is_data_stale(self) -> bool:
           """Check if data timeout exceeded."""
           elapsed = (datetime.now() - self.last_data_time).total_seconds()
           return elapsed > self.timeout_seconds
   ```

4. **Reconnection with Exponential Backoff:**
   ```python
   import random

   async def connect_with_backoff(url: str, subscribe_msg: dict, callback):
       """Connect with automatic reconnection and exponential backoff."""
       base_delay = 1
       max_delay = 60
       delay = base_delay

       while True:
           try:
               async with websockets.connect(url) as ws:
                   # Reset delay on successful connection
                   delay = base_delay

                   # Subscribe
                   await ws.send(json.dumps(subscribe_msg))

                   # Start heartbeat
                   heartbeat_task = asyncio.create_task(heartbeat(ws))

                   try:
                       async for message in ws:
                           data = json.loads(message)
                           await callback(data)
                   finally:
                       heartbeat_task.cancel()

           except websockets.ConnectionClosed as e:
               print(f"Connection closed: {e.code}, reconnecting in {delay}s...")

           except Exception as e:
               print(f"Error: {e}, reconnecting in {delay}s...")

           await asyncio.sleep(delay)
           delay = min(delay * 2 + random.random(), max_delay)
   ```

5. **Complete Robust Connection Class:**
   ```python
   class RobustWebSocket:
       def __init__(self, url: str, subscribe_msg: dict):
           self.url = url
           self.subscribe_msg = subscribe_msg
           self.running = False
           self.last_data_time = None
           self.data_timeout = 300  # 5 minutes
           self.heartbeat_interval = 5

       async def connect(self, callback):
           """Connect with full lifecycle management."""
           self.running = True

           while self.running:
               try:
                   async with websockets.connect(self.url) as ws:
                       print(f"Connected to {self.url}")

                       # Subscribe
                       await ws.send(json.dumps(self.subscribe_msg))
                       self.last_data_time = datetime.now()

                       # Start background tasks
                       tasks = [
                           asyncio.create_task(self._heartbeat(ws)),
                           asyncio.create_task(self._check_data_timeout())
                       ]

                       try:
                           async for message in ws:
                               self.last_data_time = datetime.now()
                               data = json.loads(message)
                               await callback(data)

                       finally:
                           for task in tasks:
                               task.cancel()

               except websockets.ConnectionClosed:
                   print("Connection closed, reconnecting in 5s...")
                   await asyncio.sleep(5)

               except DataTimeoutError:
                   print("Data timeout, forcing reconnect...")
                   # Connection will be closed, loop continues

               except Exception as e:
                   print(f"Error: {e}, reconnecting in 10s...")
                   await asyncio.sleep(10)

       async def _heartbeat(self, ws):
           """Periodic ping to keep connection alive."""
           while True:
               await asyncio.sleep(self.heartbeat_interval)
               await ws.ping()

       async def _check_data_timeout(self):
           """Check for data timeout every minute."""
           while True:
               await asyncio.sleep(60)
               if self.last_data_time:
                   elapsed = (datetime.now() - self.last_data_time).total_seconds()
                   if elapsed > self.data_timeout:
                       raise DataTimeoutError("No data received for 5 minutes")

       def stop(self):
           self.running = False

   class DataTimeoutError(Exception):
       pass
   ```

6. **Subscription State Restoration:**
   ```python
   class SubscriptionManager:
       def __init__(self):
           self.subscribed_tokens = set()
           self.subscribed_markets = set()

       def add_market_subscription(self, token_ids: list):
           self.subscribed_tokens.update(token_ids)

       def add_user_subscription(self, market_ids: list):
           self.subscribed_markets.update(market_ids)

       def get_market_subscribe_msg(self):
           return {
               "type": "market",
               "assets_ids": list(self.subscribed_tokens)
           }

       def get_user_subscribe_msg(self, api_creds: dict):
           return {
               "type": "user",
               "auth": api_creds,
               "markets": list(self.subscribed_markets)
           }
   ```

7. **Best Practices Summary:**
   - **Heartbeat:** Send ping every 5 seconds
   - **Data timeout:** Reconnect if no data for 5 minutes
   - **Exponential backoff:** Start at 1s, max 60s, with jitter
   - **Subscription tracking:** Restore subscriptions after reconnect
   - **Graceful shutdown:** Cancel tasks, close connection cleanly

8. **Monitoring and Logging:**
   ```python
   import logging

   logging.basicConfig(level=logging.INFO)
   logger = logging.getLogger("polymarket_ws")

   class MonitoredWebSocket(RobustWebSocket):
       async def connect(self, callback):
           connect_count = 0

           while self.running:
               connect_count += 1
               logger.info(f"Connection attempt #{connect_count}")

               try:
                   # ... connection logic ...
                   logger.info(f"Connected successfully")

               except websockets.ConnectionClosed as e:
                   logger.warning(f"Connection closed: {e.code}")

               except Exception as e:
                   logger.error(f"Connection error: {e}")
   ```
  </action>
  <verify>File exists at skills/polymarket/real-time/connection-management.md with 100+ lines, includes heartbeat, data timeout detection, reconnection with backoff, and subscription restoration</verify>
  <done>Connection management documentation with robust lifecycle handling patterns</done>
</task>

</tasks>

<verification>
After completion, real-time skill folder is complete with 5 files:
- README.md (Plan 07)
- websocket-overview.md (Plan 07)
- market-channel.md (Plan 07)
- user-channel.md (this plan)
- connection-management.md (this plan)

All WebSocket requirements (WS-01 through WS-05) are covered.
</verification>

<success_criteria>
1. User channel authentication documented with credential format
2. Order events (PLACEMENT, MATCHED, CANCELLATION) documented
3. Trade notification lifecycle (MATCHED -> MINED -> CONFIRMED) documented
4. Heartbeat pattern documented (5 second ping)
5. Data timeout detection documented (5 minute threshold)
6. Reconnection with exponential backoff documented
7. Subscription state restoration pattern included
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-api-documentation/02-08-SUMMARY.md`

Update skills/polymarket/real-time/README.md to add links to new files.
</output>
